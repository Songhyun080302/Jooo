<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>주지윤의 미연시 — 풀게임</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#071422; --card:rgba(4,8,15,0.6); --accent:#ffca28; --text:#eef6ff;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; font-family:"Noto Sans KR",system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial; background:var(--bg); color:var(--text); overflow:hidden}
  #game{position:relative; width:100vw; height:100vh;}
  /* 배경(씬) */
  .bg {
    position:absolute; inset:0; background:linear-gradient(180deg,#091226 0%, #08101a 100%); background-size:cover; background-position:center; transition:opacity .45s ease, transform .6s ease;
  }
  /* 캐릭터 스탠딩(플레이스홀더) */
  .chars {
    position:absolute; left:0; right:0; bottom:10vh; height:60vh; pointer-events:none;
    display:flex; align-items:end; justify-content:center; gap:2%;
  }
  .char {
    width:25%; max-width:320px; opacity:0; transform:translateY(20px); transition:all .45s ease; pointer-events:none;
    filter:drop-shadow(0 20px 40px rgba(2,6,23,0.6));
  }
  .char.show { opacity:1; transform:translateY(0); }

  /* 대사창 */
  .ui {
    position:absolute; left:50%; transform:translateX(-50%); bottom:2vh; width:92%; max-width:1100px;
  }
  .textbox {
    background: linear-gradient(180deg, rgba(6,10,16,0.72), rgba(10,14,22,0.68));
    border:1px solid rgba(255,255,255,0.04);
    backdrop-filter: blur(8px);
    border-radius:14px; padding:18px; display:flex; gap:16px; align-items:flex-start;
    box-shadow: 0 20px 60px rgba(2,6,23,0.6);
  }
  .left-meta {width:12%; min-width:110px; display:flex; align-items:center; justify-content:center;}
  .avatar {
    width:80px; height:80px; border-radius:10px; background:linear-gradient(180deg,#232b34,#11161b); display:flex;align-items:center; justify-content:center; font-weight:900; color:rgba(255,255,255,0.12);
    border:1px solid rgba(255,255,255,0.04);
  }
  .right-box {flex:1;}
  .name {font-weight:800; color:var(--accent); font-size:18px; margin-bottom:6px;}
  .text {min-height:64px; font-size:17px; line-height:1.6; white-space:pre-wrap;}
  .controls {margin-top:12px; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}

  /* 선택지 */
  .choices {display:flex; flex-direction:column; gap:10px; width:100%; margin-top:8px;}
  .choice-btn {
    background: rgba(255,255,255,0.06);
    border:1px solid rgba(255,255,255,0.04);
    color:var(--text); padding:10px 14px; border-radius:10px; text-align:left; font-weight:700;
    cursor:pointer; transition:all .12s;
  }
  .choice-btn:hover { transform:translateY(-3px); box-shadow:0 8px 30px rgba(1,6,12,0.6); }

  /* small UI */
  .meta-row {display:flex; gap:8px; align-items:center; justify-content:space-between; margin-top:8px;}
  .small {font-size:13px; color:rgba(255,255,255,0.6);}
  .btn {
    background:var(--accent); border:none; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:800; color:#08121a;
  }

  /* 엔딩 overlay */
  .overlay {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(2,6,11,0.6), rgba(2,6,11,0.8));
    z-index:40; opacity:0; pointer-events:none; transition:opacity .3s;
  }
  .overlay.show {opacity:1; pointer-events:auto;}
  .ending-card {background:rgba(255,255,255,0.03); padding:28px; border-radius:12px; text-align:center; border:1px solid rgba(255,255,255,0.04)}
  .ending-card h2{margin:0 0 8px 0; color:var(--accent)}
  .ending-card p{color:var(--text); margin:8px 0 16px 0}
  .ending-card .again{background:var(--accent); color:#08121a; border:none; padding:10px 14px; border-radius:8px; font-weight:800; cursor:pointer}

  @media (max-width:720px){
    .char {width:36%}
    .left-meta {display:none}
    .textbox {flex-direction:column; gap:10px}
  }
</style>
</head>
<body>
  <div id="game">
    <div id="bg" class="bg"></div>

    <div class="chars" id="chars">
      <!-- 플레이스홀더 캐릭터 이미지(교체 가능) -->
      <img id="char-left" class="char" src="" alt="" style="display:none">
      <img id="char-center" class="char" src="" alt="">
      <img id="char-right" class="char" src="" alt="">
    </div>

    <div class="ui">
      <div class="textbox">
        <div class="left-meta">
          <div class="avatar" id="avatar">YN</div>
        </div>

        <div class="right-box">
          <div class="name" id="speaker">시스템</div>
          <div class="text" id="text">로딩 중...</div>

          <div class="controls">
            <div class="choices" id="choices"></div>
            <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
              <div class="small" id="hint">엔터/스페이스로 대사 스킵</div>
              <button class="btn" id="restartBtn">처음으로</button>
            </div>
          </div>

        </div>
      </div>
      <div class="meta-row" style="margin-top:8px; color:rgba(255,255,255,0.18)">
        <div class="small">풀게임 버전 · 제공하신 분기 모두 반영됨</div>
        <div class="small">이미지는 플레이스홀더 — 원하시면 교체해드립니다</div>
      </div>
    </div>

    <div class="overlay" id="overlay">
      <div class="ending-card">
        <h2 id="endingTitle">엔딩</h2>
        <p id="endingText">엔딩 텍스트</p>
        <button class="again" id="againBtn">다시 시작</button>
      </div>
    </div>
  </div>

<script>
/* ---------------------------
   전체 스토리(원본을 충실히 반영)
   각 노드는 id, speaker, text, choices[], bg, char, end(bool) 등으로 구성
   --------------------------- */

const story = {
  start: {
    speaker:"나레이션",
    text:"->게임 시작 (똑똑똑)\n->문을 연다\n->문을 열지 않는다->end\n->문을 열면 진행됩니다.",
    bg:null,
    choices:[
      {text:"문을 열지 않는다 → end", next:"door_close_end"},
      {text:"문을 연다", next:"open_door"}
    ]
  },

  door_close_end: { speaker:"나레이션", text:"당신은 문을 열지 않았습니다.\n— END", end:true },

  open_door: {
    speaker:"SEVENTEEN",
    text:"<안녕 지윤아! 오늘 우리 데이트 하는 날이라 마중 나왔어> (손을 내밀며)\n<오늘은 나랑 데이트 해줄거지?>",
    choices:[
      {text:"민규의 손을 잡는다", next:"grab_mingu"},
      {text:"호시의 손을 잡는다", next:"grab_hoshi"}
    ],
    bg:null, char:null
  },

  grab_hoshi: { speaker:"나레이션", text:"(수진이의 분노로 지구가 멸망했습니다)\n— END", end:true },

  grab_mingu: {
    speaker:"민규",
    text:"<너네는 아직 나한테 안돼>",
    choices:[
      {text:"아 진짜 준비도 다 안했는데 왜이렇게 재촉해!!!!! (1)", next:"choice1_react"},
      {text:"음 잠시만 민규야ㅎㅎ 나 이제 옷만 입으면 끝나ㅎㅎ (2)", next:"choice2_react"}
    ],
    char:null
  },

  choice1_react: {
    speaker:"나레이션",
    text:"(상처받은 얼굴로) 왜 그렇게 말해ㅜㅜ\n원우: <늫ㅎ 민규야 우리 그냥 집에 가서 쉬자>\n민규:<됐어 나 집 가서 원우형이랑 놀거야 흥>\n(당신의 매정한 말에 상처를 받은 민규는 당신과 결혼할 마음을 접었습니다.)",
    end:true
  },

  choice2_react: {
    speaker:"나레이션",
    text:"<응 지윤아ㅎㅎ 기다릴게ㅎㅎ>\n(이런 미친 김민규 왤케 귀여워??)\n(벽으로 민규를 끌어 당긴다)\n<지윤아! 이게 뭐하는거야>",
    choices:[
      {text:"손으로 벽을 쾅 내리친다", next:"smash_wall"},
      {text:"실수를 인정하고 다시 고이 자리에 앉힌다", next:"calm_down"}
    ]
  },

  smash_wall: {
    speaker:"나레이션",
    text:"(벽이 우르르쾅쾅 무너지며)\n(이런..힘조절 실패인가)\n<집 벽을 부수는 여자는 나와 맞지 않는 것 같아 나 집에 갈래!!>\n(당신의 괴력에 경악을 금치 못합니다)",
    end:true
  },

  calm_down: {
    speaker:"지윤",
    text:"미안 많이 놀랐어? 너가 너무 귀여워서 그만.. \n(설레는 말에 민규의 호감도가 20 올랐습니다)",
    choices:[
      {text:"계속", next:"knock_again"}
    ]
  },

  knock_again: {
    speaker:"나레이션",
    text:"(그때 똑똑- 노크 소리가 다시 한번 들려왔다)\n수진:<주지윤! 준비 다함? 데리러옴~>\n지윤:(아 맞다.. 나 오늘 쟤랑 놀기로 했었지..)",
    choices:[
      {text:"야 미안 나 오늘 민규랑 놀기로 함", next:"choose_mingu"},
      {text:"아 맞다! 민규야 미안.. 나 오늘 사랑하는 수진이랑 놀아야 돼", next:"choose_sujin"}
    ]
  },

  choose_mingu: {
    speaker:"나레이션",
    text:"미친 민규가 너랑 논다고? 호시는 어딨음?\n(호시를 찾아 떠났습니다)",
    end:true
  },

  choose_sujin: {
    speaker:"수진",
    text:"<헐 미친 민규를 버리고 나를 선택해 준거야..?>\n<지윤아..나랑 사귀자>\n(지윤과 수진이 결혼했습니다)",
    end:true
  },

  // --- 시내 장면 연결 ---
  after_scene: {
    speaker:"나레이션",
    text:"<그럼 우리 이제 시내가자!!>\n(갑자기 준휘♡송현이 등장했습니다)\n<민규지윤! 너네의 그 사이좋은 모습이 너무 꼴보기 싫어!>\n<당장 떨어지지 않으면 우리가 헤어지겠어!>",
    choices:[
      {text:"우정", next:"friend_choice"},
      {text:"사랑", next:"love_choice"}
    ]
  },

  friend_choice: { speaker:"준휘", text:"<ㅎㅎ 고마워 지윤아 나 갈게~>", end:true },

  love_choice: {
    speaker:"나레이션",
    text:"(준휘와 송현이 헤어졌습니다)\n지윤:<준휘송현이 헤어지다니.. 안타깝다..>\n민규:<어쩔수없지뭐ㅎㅎ 우리 밥먹으러 갈까?>\n민규: <우리 뭐 먹을까?>",
    choices:[
      {text:"마라탕", next:"malatang_end"},
      {text:"민규정식", next:"mingu_set"}
    ]
  },

  malatang_end: { speaker:"나레이션", text:"(마라탕을 좋아하는 수진이와 다희만 기뻐합니다)\n— END", end:true },

  mingu_set: {
    speaker:"민규",
    text:"<헉 나도 그거 먹고 싶었어>\n(그때 한 쪽에서 큰 소리가 들려왔다)\n... : 워쓰창슈!!\n수진: 워쓰라오후!! 진정해!!\n호시: 워쓰창슈!!\n민규: <에이 호시 형은 햄스터지~>",
    choices:[
      {text:"뒤통수를 친다", next:"hit_back"},
      {text:"동조한다", next:"agree_hamster"}
    ]
  },

  hit_back: { speaker:"나레이션", text:"(민규가 상처받은 눈으로 뛰쳐나갑니다)\n— END", end:true },

  agree_hamster: {
    speaker:"나레이션",
    text:"<그치 호시는 햄스터지>\n(수진이가 배신감 어린 표정으로 쳐다보지만 민규와 공감대를 형성했습니다)\n->(밥이 나왔다)\n->(민규가 갑자기 분위기를 잡는다)\n민규:<지윤아 나 사실 내일 군대가..>",
    choices:[
      {text:"기다린다", next:"wait_military"},
      {text:"기다리지 않는다", next:"dont_wait"}
    ]
  },

  dont_wait: {
    speaker:"지윤",
    text:"<원우형이 면회 와준댔어 그럼 안녕>",
    next:"visit_scene"
  },

  wait_military: {
    speaker:"지윤",
    text:"<정말?ㅎㅎ 그럼 면회 와줄거지?>",
    next:"visit_scene"
  },

  visit_scene: {
    speaker:"나레이션",
    text:"(3 months later...)\n(오늘은 드디어 민규의 면회날이다)\n지윤: 민규를 위해 고무신을 신고 가야겠어!",
    choices:[
      {text:"거꾸로 신는다", next:"flip_shoes"},
      {text:"똑바로 신는다", next:"normal_shoes"}
    ]
  },

  flip_shoes: {
    speaker:"나레이션",
    text:"<거꾸로 신으면 개간지나죠?>\n<민규야 나왔어~>\n<지윤아.. 너 바람피워? 실망이야>",
    end:true
  },

  normal_shoes: {
    speaker:"나레이션",
    text:"<하.. 똑바로 신으면 간지가 안나는데..>\n<민규야 나왔어~>\n<ㅎㅎ 지윤아 고무신 귀엽다>\n<와줘서 고마워~>\n<민규야 나 오늘 너한테 할말이 있어..>\n<웅 뭔데?>\n<민규야 사실 나..>\n(고백을 할것이다 누구한테 고백할것인가?)",
    choices:[
      {text:"김민규.....1", next:"confess_mingu1"},
      {text:"김민규.....2", next:"confess_mingu2"}
    ]
  },

  confess_mingu1: { speaker:"배우 김민규", text:"<그래!! 우리 사귀자!>\n— END", end:true },

  confess_mingu2: {
    speaker:"김민규",
    text:"<나..? 그래! 우리 사귀자!>\n(주지윤♡김민규의 사랑이 이루어졌습니다)\n(few months later...)",
    next:"wedding_prep"
  },

  wedding_prep: {
    speaker:"나레이션",
    text:"(지윤♡민규는 결혼 준비 중이다)\n<지윤아 나 머리 많이 길렀지!>\n<시발 김민규 너 머리 안자르면 파혼>",
    choices:[
      {text:"라푼젤....1", next:"rapunzel"},
      {text:"변발.....2", next:"punk"}
    ]
  },

  rapunzel: { speaker:"민규", text:"<지윤아ㅜㅜ 내 삶을 인정해 주는구나ㅜㅜ>\n<우리 결혼해서 행복하게 살자ㅜ>", end:true },
  punk: { speaker:"지윤", text:"<내 삶을 무시하는구나 우리 헤어지자>\n— END", end:true }
};

/* ---------------------------
   게임 엔진(렌더링, 타자효과, 키 조작 등)
   --------------------------- */

const $ = id => document.getElementById(id);
const speakerEl = $('speaker');
const textEl = $('text');
const choicesEl = $('choices');
const bgEl = $('bg');
const avatarEl = $('avatar');
const overlay = $('overlay');
const endingTitle = $('endingTitle');
const endingText = $('endingText');
const againBtn = $('againBtn');
const restartBtn = $('restartBtn');

let currentNodeId = 'start';
let typing = false;
let typeTimer = null;
let fullText = '';
let typeIndex = 0;

function setBackground(bg){
  if(!bg){ bgEl.style.backgroundImage = ''; bgEl.style.background = 'linear-gradient(180deg,#091226,#08101a)'; return; }
  bgEl.style.backgroundImage = `url(${bg})`;
}

function renderNode(id){
  if(!story[id]) { console.error("missing node", id); return; }
  currentNodeId = id;
  const node = story[id];

  // speaker & avatar
  speakerEl.textContent = node.speaker || '';
  avatarEl.textContent = (node.speaker || '').slice(0,2).toUpperCase();

  // bg
  setBackground(node.bg || null);

  // choices: clear existing
  choicesEl.innerHTML = '';

  // handle text with typewriter effect
  startTyping(node.text || '');

  // if node has choices -> render them after typing (but clickable anytime)
  if(node.choices){
    node.choices.forEach((c, idx) => {
      const btn = document.createElement('button');
      btn.className = 'choice-btn';
      btn.textContent = (idx+1) + ". " + c.text;
      btn.addEventListener('click', ()=> { goTo(c.next); });
      choicesEl.appendChild(btn);
    });
  } else {
    // if node has explicit 'next' field (like some nodes), allow continue button
    if(node.next){
      const btn = document.createElement('button');
      btn.className = 'choice-btn';
      btn.textContent = '계속';
      btn.addEventListener('click', ()=> { goTo(node.next); });
      choicesEl.appendChild(btn);
    }
  }

  // If node is end: show overlay after typing finishes
  if(node.end){
    // ensure overlay shows after typing done
    // we'll call showEnding inside finishTyping
  }
}

function startTyping(text){
  // cancel previous
  if(typeTimer) { clearInterval(typeTimer); typeTimer = null; }
  typing = true;
  fullText = text;
  typeIndex = 0;
  textEl.textContent = '';
  // show one character at a time
  typeTimer = setInterval(()=> {
    typeIndex++;
    textEl.textContent = fullText.slice(0, typeIndex);
    if(typeIndex >= fullText.length){
      clearInterval(typeTimer); typeTimer = null; typing = false;
      // if current node is end -> show overlay
      const node = story[currentNodeId];
      if(node && node.end){
        setTimeout(()=> showEnding(node.text), 240);
      }
    }
  }, 16); // 빠르게 (타자감)
}

// 스킵 / 즉시완료
function finishTypingNow(){
  if(typeTimer){ clearInterval(typeTimer); typeTimer = null; }
  typing = false;
  textEl.textContent = fullText;
  // if node is end -> show overlay
  const node = story[currentNodeId];
  if(node && node.end){
    setTimeout(()=> showEnding(node.text), 120);
  }
}

function goTo(nextId){
  const node = story[nextId];
  if(!node){
    // 안전망: 노드 없으면 엔딩 처리
    showEnding("오류: 해당 분기가 존재하지 않습니다. (엔딩 처리)");
    return;
  }
  // If node has immediate 'next' without choices, allow chaining
  if(node.next && !node.choices){
    renderNode(nextId);
    // automatically continue when finished typing
    // We rely on node.next to be followed by user clicking "계속" if needed.
  } else {
    renderNode(nextId);
  }
}

// 엔딩 오버레이 표시
function showEnding(text){
  overlay.classList.add('show');
  endingTitle.textContent = "엔딩 도달";
  endingText.textContent = text.replace(/\n/g,'\n');
}

// 키 제어: 스페이스 / 엔터 => 타자 스킵 또는 다음(가능하면)
document.addEventListener('keydown', (e)=>{
  if(e.key === ' ' || e.key === 'Enter'){
    e.preventDefault();
    if(typing) finishTypingNow();
  }
});

// 버튼 동작
againBtn.addEventListener('click', ()=> {
  overlay.classList.remove('show');
  startGame();
});
restartBtn.addEventListener('click', ()=> startGame());

// 초기 시작
function startGame(){
  overlay.classList.remove('show');
  renderNode('start');
}

// 시작
startGame();

</script>
</body>
</html>
